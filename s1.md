# Angular Core Building Blocks and Templates Documentation

## Table of Contents

| # | Topic |
|---|-------|
| **Core Building Blocks** | |
| 1 | [Property Binding](#property-binding) |
| 2 | [Event Binding](#event-binding) |
| 3 | [Two-Way Data Binding](#two-way-data-binding) |
| 4 | [Class and Style Binding](#class-and-style-binding) |
| 5 | [Structural Directives](#structural-directives) |
| 6 | [Attribute Directives](#attribute-directives) |
| 7 | [Custom Directives](#custom-directives) |
| 8 | [Built-in Pipes](#built-in-pipes) |
| 9 | [Custom Pipes](#custom-pipes) |
| **Angular Templates in Depth** | |
| 10 | [Template Reference Variables](#template-reference-variables) |
| 11 | [Content Projection with ng-content](#content-projection-with-ng-content) |
| 12 | [ng-container and ng-template](#ng-container-and-ng-template) |
| 13 | [ViewChild and ViewChildren](#viewchild-and-viewchildren) |
| 14 | [Content Children and View Children](#content-children-and-view-children) |

## Property Binding

Property binding in Angular allows you to set properties of target elements or directives. It's a one-way data flow from a component's data property to a target element property.

### Key Features

* One-way binding from component to DOM
* Uses square brackets `[property]="expression"` syntax
* Updates when component property changes
* Can bind to standard HTML properties, custom properties, and directive inputs

### Examples

**Basic Property Binding**

```typescript
// component.ts
@Component({
  selector: 'app-property-binding',
  templateUrl: './property-binding.component.html'
})
export class PropertyBindingComponent {
  imageUrl = 'https://angular.io/assets/images/logos/angular/angular.png';
  isDisabled = true;
  buttonText = 'Click Me';
}
```

```html
<!-- property-binding.component.html -->
<!-- Binding to the src property of an image -->
<img [src]="imageUrl" alt="Angular Logo">

<!-- Binding to the disabled property of a button -->
<button [disabled]="isDisabled">{{ buttonText }}</button>

<!-- The following are equivalent -->
<button [disabled]="isDisabled">Button</button>
<button bind-disabled="isDisabled">Button</button>
```

**Property Binding to Custom Components**

```typescript
// parent.component.ts
@Component({
  selector: 'app-parent',
  template: `
    <app-child [message]="parentMessage"></app-child>
    <button (click)="updateMessage()">Update Message</button>
  `
})
export class ParentComponent {
  parentMessage = 'Message from parent';
  
  updateMessage() {
    this.parentMessage = 'Updated message from parent';
  }
}

// child.component.ts
@Component({
  selector: 'app-child',
  template: `<p>{{ message }}</p>`
})
export class ChildComponent {
  @Input() message: string = '';
}
```

### Best Practices

* Use property binding instead of string interpolation when setting element properties
* Be aware that property names are case-sensitive
* Remember that property binding works with properties, not attributes (HTML attributes initialize DOM properties)
* Avoid complex expressions in templates - move logic to the component

[Back to Top](#table-of-contents)

## Event Binding

Event binding allows you to listen for and respond to user actions such as keystrokes, mouse movements, clicks, and touches.

### Key Features

* One-way data flow from the view to the component
* Uses parentheses `(event)="handler()"` syntax
* Connects DOM events to component methods
* Can pass event data to the component method

### Examples

**Basic Event Binding**

```typescript
// component.ts
@Component({
  selector: 'app-event-binding',
  templateUrl: './event-binding.component.html'
})
export class EventBindingComponent {
  clickCount = 0;
  
  incrementCount() {
    this.clickCount++;
    console.log(`Button clicked ${this.clickCount} times`);
  }
  
  onKeyUp(event: KeyboardEvent) {
    console.log('Key pressed:', event.key);
  }
}
```

```html
<!-- event-binding.component.html -->
<button (click)="incrementCount()">Click me</button>
<p>Button clicked: {{ clickCount }} times</p>

<input (keyup)="onKeyUp($event)" placeholder="Type something">

<!-- Alternative syntax -->
<button on-click="incrementCount()">Click me (alternative syntax)</button>
```

**Output** (After clicking the button twice):
```
Button clicked 2 times
```

**Custom Event Binding with EventEmitter**

```typescript
// child.component.ts
@Component({
  selector: 'app-child',
  template: `
    <button (click)="sendMessageToParent()">Send Message to Parent</button>
  `
})
export class ChildComponent {
  @Output() messageEvent = new EventEmitter<string>();
  
  sendMessageToParent() {
    this.messageEvent.emit('Hello from child!');
  }
}

// parent.component.ts
@Component({
  selector: 'app-parent',
  template: `
    <app-child (messageEvent)="receiveMessage($event)"></app-child>
    <p>{{ message }}</p>
  `
})
export class ParentComponent {
  message = '';
  
  receiveMessage(msg: string) {
    this.message = msg;
  }
}
```

### Event Filtering

```typescript
@Component({
  selector: 'app-key-filter',
  template: `
    <input (keyup.enter)="onEnterPressed($event)" placeholder="Press Enter">
  `
})
export class KeyFilterComponent {
  onEnterPressed(event: KeyboardEvent) {
    console.log('Enter pressed, input value:', (event.target as HTMLInputElement).value);
  }
}
```

### Best Practices

* Keep event handlers simple or call methods that contain complex logic
* Use the `$event` object to access event data when needed
* Consider event filtering for keyboard, mouse, and other events
* Clean up event listeners in `ngOnDestroy` if using direct DOM event listeners

[Back to Top](#table-of-contents)

## Two-Way Data Binding

Two-way data binding combines property binding and event binding. It enables a two-way flow of data between the template and component, making it easy to synchronize values.

### Key Features

* Combines property binding and event binding
* Uses banana-in-a-box syntax `[(ngModel)]="property"`
* Automatically updates both the model and the view
* Requires the FormsModule to be imported for ngModel

### Examples

**Basic Two-Way Binding with ngModel**

```typescript
// app.module.ts
import { FormsModule } from '@angular/forms';

@NgModule({
  imports: [
    BrowserModule,
    FormsModule // Required for ngModel
  ],
  // other configurations
})
export class AppModule { }

// component.ts
@Component({
  selector: 'app-two-way',
  templateUrl: './two-way.component.html'
})
export class TwoWayComponent {
  name = 'John Doe';
  
  updateName() {
    this.name = 'Jane Smith';
  }
}
```

```html
<!-- two-way.component.html -->
<input [(ngModel)]="name" placeholder="Enter name">
<p>Current name: {{ name }}</p>
<button (click)="updateName()">Update Name</button>
```

**Under the Hood - How Two-Way Binding Works**

```html
<!-- The following are equivalent -->
<input [(ngModel)]="name">

<!-- This is what [(ngModel)] expands to -->
<input [ngModel]="name" (ngModelChange)="name = $event">
```

**Custom Two-Way Binding**

```typescript
// counter.component.ts
@Component({
  selector: 'app-counter',
  template: `
    <div>
      <button (click)="decrement()">-</button>
      <span>{{ value }}</span>
      <button (click)="increment()">+</button>
    </div>
  `
})
export class CounterComponent {
  @Input() value: number = 0;
  @Output() valueChange = new EventEmitter<number>();
  
  increment() {
    this.value++;
    this.valueChange.emit(this.value);
  }
  
  decrement() {
    this.value--;
    this.valueChange.emit(this.value);
  }
}

// parent.component.ts
@Component({
  selector: 'app-parent',
  template: `
    <app-counter [(value)]="counterValue"></app-counter>
    <p>Counter value: {{ counterValue }}</p>
  `
})
export class ParentComponent {
  counterValue = 5;
}
```

### Best Practices

* Import FormsModule in your application module to use ngModel
* Use two-way binding sparingly for simpler forms and component interactions
* For complex forms, consider using Reactive Forms instead
* Follow naming convention of `[property]` and `(propertyChange)` for custom two-way binding

[Back to Top](#table-of-contents)

## Class and Style Binding

Class and style binding allows you to dynamically add or remove CSS classes and inline styles based on component state.

### Key Features

* Dynamically manipulate CSS classes and styles
* Class binding uses `[class]` or `[class.className]` syntax
* Style binding uses `[style]` or `[style.styleName]` syntax
* Supports adding/removing multiple classes and styles at once

### Examples

**Class Binding**

```typescript
// component.ts
@Component({
  selector: 'app-class-binding',
  templateUrl: './class-binding.component.html',
  styles: [`
    .text-success { color: green; }
    .text-danger { color: red; }
    .text-large { font-size: 24px; }
    .bold { font-weight: bold; }
  `]
})
export class ClassBindingComponent {
  isSpecial = true;
  canSave = false;
  status = 'error';
  
  // Object for [class] binding
  classObject = {
    'text-success': false,
    'text-danger': true,
    'text-large': true,
    'bold': true
  };
  
  toggleSpecial() {
    this.isSpecial = !this.isSpecial;
  }
}
```

```html
<!-- class-binding.component.html -->
<!-- Single class binding -->
<div [class.text-success]="isSpecial">Text with conditional class binding</div>

<!-- Multiple classes using ngClass with an object -->
<div [ngClass]="{'text-success': isSpecial, 'bold': isSpecial, 'text-large': !isSpecial}">
  Multiple class binding with object
</div>

<!-- Multiple classes using ngClass with a method -->
<div [ngClass]="getClasses()">Multiple class binding with method</div>

<!-- Multiple classes using [class] with object -->
<div [class]="classObject">Multiple class binding with class object</div>

<!-- Multiple classes using [class] with string -->
<div [class]="isSpecial ? 'text-success bold' : 'text-danger'">Class binding with string</div>
```

```typescript
// Additional method for the component
getClasses() {
  return {
    'text-success': this.status === 'success',
    'text-danger': this.status === 'error',
    'bold': this.canSave
  };
}
```

**Style Binding**

```typescript
// component.ts
@Component({
  selector: 'app-style-binding',
  templateUrl: './style-binding.component.html'
})
export class StyleBindingComponent {
  isBold = true;
  fontSize = 16;
  textColor = 'blue';
  
  // Object for [style] binding
  styleObject = {
    'color': 'purple',
    'font-weight': 'bold',
    'font-size.px': 20
  };
  
  toggleWeight() {
    this.isBold = !this.isBold;
  }
}
```

```html
<!-- style-binding.component.html -->
<!-- Single style binding -->
<div [style.font-weight]="isBold ? 'bold' : 'normal'">Text with conditional style binding</div>

<!-- Style binding with units -->
<div [style.font-size.px]="fontSize">Text with style binding and units</div>

<!-- Multiple styles using ngStyle -->
<div [ngStyle]="{'color': textColor, 'font-weight': isBold ? 'bold' : 'normal'}">
  Multiple style binding with ngStyle
</div>

<!-- Multiple styles using [style] with object -->
<div [style]="styleObject">Multiple style binding with style object</div>
```

### Comparison: Class vs Style Binding

| Feature | Class Binding | Style Binding |
|---------|---------------|---------------|
| **Basic Syntax** | `[class.className]="expression"` | `[style.styleName]="expression"` |
| **Multiple Values** | `[class]="{class1: expr1, class2: expr2}"` | `[style]="{style1: expr1, style2: expr2}"` |
| **Directive Form** | `[ngClass]="classExpression"` | `[ngStyle]="styleExpression"` |
| **Use Case** | When working with predefined CSS classes | For dynamic inline styles |
| **Performance** | Better for grouped styling changes | Use when styles need to be calculated |
| **Units** | N/A | Supports unit extensions (px, em, %, etc.) |

### Best Practices

* Use class binding over style binding when possible
* Prefer component CSS and class binding for most styling needs
* Use style binding for dynamic styles that depend on component state
* Avoid complex expressions in templates - compute styles/classes in component code
* Consider using `[ngClass]` and `[ngStyle]` for complex scenarios with multiple classes/styles

[Back to Top](#table-of-contents)

## Structural Directives

Structural directives modify the DOM layout by adding, removing, or manipulating elements. They are denoted by an asterisk (*) prefix.

### Key Features

* Change the structure of the DOM layout
* Use asterisk (*) prefix syntax as shorthand for `<ng-template>`
* Core structural directives: *ngIf, *ngFor, *ngSwitch
* Can't have multiple structural directives on the same element

### Examples

**ngIf - Conditional Rendering**

```typescript
// component.ts
@Component({
  selector: 'app-ngif-example',
  templateUrl: './ngif-example.component.html'
})
export class NgIfExampleComponent {
  showContent = true;
  isLoggedIn = false;
  userRole = 'admin';
  
  toggleContent() {
    this.showContent = !this.showContent;
  }
  
  login() {
    this.isLoggedIn = true;
  }
  
  logout() {
    this.isLoggedIn = false;
  }
}
```

```html
<!-- ngif-example.component.html -->
<!-- Basic ngIf -->
<div *ngIf="showContent">Content is visible when showContent is true</div>
<button (click)="toggleContent()">Toggle Content</button>

<!-- ngIf with else template -->
<div *ngIf="isLoggedIn; else loginTemplate">
  Welcome User! You are logged in.
  <button (click)="logout()">Logout</button>
</div>
<ng-template #loginTemplate>
  <button (click)="login()">Login</button>
</ng-template>

<!-- ngIf with then and else templates -->
<div *ngIf="isLoggedIn; then loggedInTemplate else loggedOutTemplate"></div>

<ng-template #loggedInTemplate>
  <p>User is authenticated</p>
  <div *ngIf="userRole === 'admin'">
    <p>Admin dashboard</p>
  </div>
</ng-template>

<ng-template #loggedOutTemplate>
  <p>Please log in to access the application</p>
</ng-template>
```

**ngFor - List Rendering**

```typescript
// component.ts
@Component({
  selector: 'app-ngfor-example',
  templateUrl: './ngfor-example.component.html'
})
export class NgForExampleComponent {
  users = [
    { id: 1, name: 'Alice', role: 'Admin' },
    { id: 2, name: 'Bob', role: 'User' },
    { id: 3, name: 'Charlie', role: 'User' },
    { id: 4, name: 'David', role: 'Manager' }
  ];
  
  addUser() {
    this.users.push({ id: this.users.length + 1, name: 'New User', role: 'User' });
  }
  
  trackById(index: number, user: any) {
    return user.id;
  }
}
```

```html
<!-- ngfor-example.component.html -->
<!-- Basic ngFor -->
<ul>
  <li *ngFor="let user of users">{{ user.name }} - {{ user.role }}</li>
</ul>

<!-- ngFor with index -->
<ul>
  <li *ngFor="let user of users; let i = index">
    {{ i + 1 }}. {{ user.name }} - {{ user.role }}
  </li>
</ul>

<!-- ngFor with multiple exported values -->
<ul>
  <li *ngFor="let user of users; 
              let i = index; 
              let first = first; 
              let last = last; 
              let even = even; 
              let odd = odd;
              trackBy: trackById">
    <span [class.text-primary]="first" [class.text-danger]="last">
      {{ i + 1 }}. {{ user.name }} - {{ user.role }}
    </span>
    <span *ngIf="even">(Even)</span>
    <span *ngIf="odd">(Odd)</span>
  </li>
</ul>

<button (click)="addUser()">Add User</button>
```

**ngSwitch - Switch Case Rendering**

```typescript
// component.ts
@Component({
  selector: 'app-ngswitch-example',
  templateUrl: './ngswitch-example.component.html'
})
export class NgSwitchExampleComponent {
  currentTab = 'home';
  userType = 'admin';
  
  switchTab(tab: string) {
    this.currentTab = tab;
  }
}
```

```html
<!-- ngswitch-example.component.html -->
<!-- Tab switching example -->
<div>
  <button (click)="switchTab('home')">Home</button>
  <button (click)="switchTab('profile')">Profile</button>
  <button (click)="switchTab('messages')">Messages</button>
  <button (click)="switchTab('settings')">Settings</button>
</div>

<div [ngSwitch]="currentTab">
  <div *ngSwitchCase="'home'">Home Content</div>
  <div *ngSwitchCase="'profile'">Profile Content</div>
  <div *ngSwitchCase="'messages'">Messages Content</div>
  <div *ngSwitchCase="'settings'">Settings Content</div>
  <div *ngSwitchDefault>Select a tab</div>
</div>

<!-- User type example -->
<div [ngSwitch]="userType">
  <div *ngSwitchCase="'admin'">
    <h3>Admin Dashboard</h3>
    <p>Full system access</p>
  </div>
  <div *ngSwitchCase="'manager'">
    <h3>Manager Dashboard</h3>
    <p>Department-level access</p>
  </div>
  <div *ngSwitchCase="'user'">
    <h3>User Dashboard</h3>
    <p>Regular user access</p>
  </div>
  <div *ngSwitchDefault>
    <h3>Guest Dashboard</h3>
    <p>Limited access</p>
  </div>
</div>
```

### Understanding Structural Directive Syntax

The asterisk (*) syntax is shorthand for `<ng-template>`. Here's how the transformation works:

```html
<!-- This -->
<div *ngIf="showContent">Content</div>

<!-- Is equivalent to this -->
<ng-template [ngIf]="showContent">
  <div>Content</div>
</ng-template>

<!-- Similarly, for ngFor -->
<div *ngFor="let item of items">{{ item }}</div>

<!-- Is equivalent to -->
<ng-template ngFor let-item [ngForOf]="items">
  <div>{{ item }}</div>
</ng-template>
```

### Best Practices

* Use `ngIf` with `else` for conditional rendering
* Implement `trackBy` with `ngFor` to improve performance with large lists
* Avoid putting multiple structural directives on a single element
* Use `ng-container` when you need multiple structural directives (see next section)
* Consider extracting complex conditional logic into component methods

[Back to Top](#table-of-contents)

## Attribute Directives

Attribute directives change the appearance or behavior of an element, component, or another directive. They are applied as attributes to elements.

### Key Features

* Do not change DOM structure, only modify elements they are attached to
* Key built-in directives: ngClass, ngStyle
* Can be applied simultaneously with other attribute directives
* Can take inputs to customize behavior

### Examples

**ngClass Directive**

```typescript
// component.ts
@Component({
  selector: 'app-ngclass-example',
  templateUrl: './ngclass-example.component.html',
  styles: [`
    .success { color: green; background-color: lightgreen; padding: 10px; }
    .warning { color: orange; background-color: lightyellow; padding: 10px; }
    .error { color: red; background-color: lightpink; padding: 10px; }
    .bold { font-weight: bold; }
    .italic { font-style: italic; }
  `]
})
export class NgClassExampleComponent {
  isSuccess = true;
  isWarning = false;
  isError = false;
  isBold = true;
  isItalic = false;
  
  messageType = 'success';
  
  // Method for ngClass
  setClasses() {
    return {
      success: this.isSuccess,
      warning: this.isWarning,
      error: this.isError,
      bold: this.isBold,
      italic: this.isItalic
    };
  }
  
  toggleSuccess() { this.isSuccess = !this.isSuccess; }
  toggleWarning() { this.isWarning = !this.isWarning; }
  toggleError() { this.isError = !this.isError; }
  toggleBold() { this.isBold = !this.isBold; }
  toggleItalic() { this.isItalic = !this.isItalic; }
}
```

```html
<!-- ngclass-example.component.html -->
<!-- String syntax -->
<div [ngClass]="'bold italic'">String syntax with hardcoded classes</div>

<!-- Array syntax -->
<div [ngClass]="['bold', 'italic']">Array syntax with hardcoded classes</div>

<!-- Object syntax -->
<div [ngClass]="{'bold': isBold, 'italic': isItalic}">
  Object syntax with conditional classes
</div>

<!-- Method syntax -->
<div [ngClass]="setClasses()">Method syntax for dynamic classes</div>

<!-- Dynamic message type example -->
<div [ngClass]="{
  'success': messageType === 'success',
  'warning': messageType === 'warning',
  'error': messageType === 'error'
}">
  Message with type: {{ messageType }}
</div>

<!-- Controls -->
<div>
  <button (click)="toggleBold()">Toggle Bold</button>
  <button (click)="toggleItalic()">Toggle Italic</button>
  <button (click)="messageType = 'success'">Success</button>
  <button (click)="messageType = 'warning'">Warning</button>
  <button (click)="messageType = 'error'">Error</button>
</div>
```

**ngStyle Directive**

```typescript
// component.ts
@Component({
  selector: 'app-ngstyle-example',
  templateUrl: './ngstyle-example.component.html'
})
export class NgStyleExampleComponent {
  color = 'blue';
  fontSize = 16;
  isBold = true;
  
  // Method for ngStyle
  setStyles() {
    return {
      'color': this.color,
      'font-size.px': this.fontSize,
      'font-weight': this.isBold ? 'bold' : 'normal'
    };
  }
  
  incrementFontSize() { this.fontSize += 2; }
  decrementFontSize() { this.fontSize -= 2; }
  toggleBold() { this.isBold = !this.isBold; }
  
  colorOptions = ['blue', 'red', 'green', 'purple', 'orange'];
  
  changeColor(newColor: string) {
    this.color = newColor;
  }
}
```

```html
<!-- ngstyle-example.component.html -->
<!-- Object syntax -->
<div [ngStyle]="{'color': color, 'font-size.px': fontSize, 'font-weight': isBold ? 'bold' : 'normal'}">
  Text styled with ngStyle object
</div>

<!-- Method syntax -->
<div [ngStyle]="setStyles()">Text styled with ngStyle method</div>

<!-- Controls -->
<div>
  <button (click)="incrementFontSize()">Increase Font</button>
  <button (click)="decrementFontSize()">Decrease Font</button>
  <button (click)="toggleBold()">Toggle Bold</button>
  
  <div>
    <p>Select color:</p>
    <button *ngFor="let colorOption of colorOptions" 
            (click)="changeColor(colorOption)"
            [style.background-color]="colorOption"
            style="margin: 2px; padding: 5px;">
      {{ colorOption }}
    </button>
  </div>
</div>
```

### Comparison: ngClass vs ngStyle

| Feature | ngClass | ngStyle |
|---------|---------|---------|
| **Purpose** | Add/remove CSS classes | Set inline styles |
| **Performance** | Better for grouped styling | Better for individual style changes |
| **Object Syntax** | `[ngClass]="{'class': expr}"` | `[ngStyle]="{'style': value}"` |
| **Array Syntax** | `[ngClass]="['class1', 'class2']"` | Not available |
| **String Syntax** | `[ngClass]="'class1 class2'"` | Not available |
| **Units** | N/A | Supports unit extensions (.px, .em, etc.) |
| **Best For** | Predefined styles in CSS | Dynamic calculated styles |

### Best Practices

* Use `ngClass` when working with predefined CSS classes
* Use `ngStyle` for truly dynamic styles that need calculation
* Extract complex style/class logic to component methods
* Remember that standard class and style bindings can be used for simpler cases
* Avoid deeply nested conditional style logic in templates

[Back to Top](#table-of-contents)

## Custom Directives

Custom directives allow you to create reusable behaviors that can be applied to elements in your templates.

### Key Features

* Extend Angular's template capabilities
* Three types: Component, Structural, and Attribute directives
* Created using `@Directive` decorator
* Can respond to user events, take inputs, and modify elements

### Examples

**Basic Attribute Directive**

```typescript
// highlight.directive.ts
import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  @Input() appHighlight = '';
  @Input() defaultColor = 'yellow';
  
  constructor(private el: ElementRef) {}
  
  @HostListener('mouseenter') onMouseEnter() {
    this.highlight(this.appHighlight || this.defaultColor);
  }
  
  @HostListener('mouseleave') onMouseLeave() {
    this.highlight('');
  }
  
  private highlight(color: string) {
    this.el.nativeElement.style.backgroundColor = color;
  }
}

// app.module.ts
@NgModule({
  declarations: [
    AppComponent,
    HighlightDirective
  ],
  // other configuration
})
export class AppModule { }
```

```html
<!-- component.html -->
<p appHighlight="lightblue">Hover over me to see highlighting</p>
<p appHighlight defaultColor="lightgreen">Hover over me with default color</p>
```

**Advanced Attribute Directive with HostBinding**

```typescript
// tooltip.directive.ts
import { Directive, Input, ElementRef, HostListener, HostBinding, Renderer2 } from '@angular/core';

@Directive({
  selector: '[appTooltip]'
})
export class TooltipDirective {
  @Input('appTooltip') tooltipText = '';
  @Input() tooltipPosition = 'top';
  
  @HostBinding('class.tooltip-host') isTooltipHost = true;
  
  private tooltipElement: HTMLElement | null = null;
  
  constructor(private el: ElementRef, private renderer: Renderer2) {}
  
  @HostListener('mouseenter') onMouseEnter() {
    this.showTooltip();
  }
  
  @HostListener('mouseleave') onMouseLeave() {
    this.hideTooltip();
  }
  
  private showTooltip() {
    // Create tooltip element
    this.tooltipElement = this.renderer.createElement('div');
    const text = this.renderer.createText(this.tooltipText);
    
    this.renderer.appendChild(this.tooltipElement, text);
    this.renderer.addClass(this.tooltipElement, 'tooltip');
    this.renderer.addClass(this.tooltipElement, `tooltip-${this.tooltipPosition}`);
    
    // Add to DOM
    this.renderer.appendChild(document.body, this.tooltipElement);
    
    // Position the tooltip
    const hostPos = this.el.nativeElement.getBoundingClientRect();
    const tooltipPos = this.tooltipElement.getBoundingClientRect();
    
    let top, left;
    
    switch(this.tooltipPosition) {
      case 'top':
        top = hostPos.top - tooltipPos.height - 10;
        left = hostPos.left + (hostPos.width - tooltipPos.width) / 2;
        break;
      case 'bottom':
        top = hostPos.bottom + 10;
        left = hostPos.left + (hostPos.width - tooltipPos.width) / 2;
        break;
      case 'left':
        top = hostPos.top + (hostPos.height - tooltipPos.height) / 2;
        left = hostPos.left - tooltipPos.width - 10;
        break;
      case 'right':
        top = hostPos.top + (hostPos.height - tooltipPos.height) / 2;
        left = hostPos.right + 10;
        break;
    }
    
    this.renderer.setStyle(this.tooltipElement, 'top', `${top}px`);
    this.renderer.setStyle(this.tooltipElement, 'left', `${left}px`);
  }
  
  private hideTooltip() {
    if (this.tooltipElement) {
      this.renderer.removeChild(document.body, this.tooltipElement);
      this.tooltipElement = null;
    }
  }
}

// CSS in global styles.css
/*
.tooltip {
  position: absolute;
  background-color: black;
  color: white;
  padding: 5px 10px;
  border-radius: 4px;
  z-index: 1000;
}

.tooltip-host {
  position: relative;
}
*/
```

```html
<!-- component.html -->
<button appTooltip="Click to save" tooltipPosition="top">Save</button>
<button appTooltip="Click to delete" tooltipPosition="bottom">Delete</button>
<span appTooltip="This is a help text">Help Icon</span>
```

**Custom Structural Directive**

```typescript
// unless.directive.ts
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appUnless]'
})
export class UnlessDirective {
  private hasView = false;

  constructor(
    private templateRef: TemplateRef<any>,
    private viewContainer: ViewContainerRef
  ) { }

  @Input() set appUnless(condition: boolean) {
    // If condition is falsy and view hasn't been created yet
    if (!condition && !this.hasView) {
      // Create the embedded view from the template
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.hasView = true;
    } else if (condition && this.hasView) {
      // If condition is truthy and view exists, clear the view
      this.viewContainer.clear();
      this.hasView = false;
    }
  }
}

// app.module.ts
@NgModule({
  declarations: [
    AppComponent,
    UnlessDirective
  ],
  // other configuration
})
export class AppModule { }
```

```html
<!-- component.html -->
<div *appUnless="condition">
  This content will be shown when the condition is false
</div>

<!-- The following is what Angular transforms the above into -->
<ng-template [appUnless]="condition">
  <div>This content will be shown when the condition is false</div>
</ng-template>
```

```typescript
// component.ts
@Component({
  selector: 'app-structural-directive-example',
  templateUrl: './structural-directive-example.component.html'
})
export class StructuralDirectiveExampleComponent {
  condition = false;
  
  toggleCondition() {
    this.condition = !this.condition;
  }
}
```

### Best Practices

* Follow naming conventions: prefix directive selectors to avoid conflicts
* Use ElementRef carefully and prefer Renderer2 for DOM manipulation
* Implement OnDestroy to clean up event listeners or subscriptions
* Consider using HostListener and HostBinding for cleaner code
* Document the API of your directives, especially inputs and outputs
* Test directives thoroughly, including edge cases
* Consider using NG_VALUE_ACCESSOR to create custom form controls

[Back to Top](#table-of-contents)

## Built-in Pipes

Pipes in Angular are simple functions that transform input values to display output in the template. Angular provides several built-in pipes for common transformations.

### Key Features

* Transform data in templates without changing the original value
* Can be chained using the pipe operator (`|`)
* Can accept parameters after the colon (`:`)
* Built-in pipes are provided by Angular's CommonModule
* Are pure by default (only recalculate when input changes)

### Examples

**String Pipes**

```typescript
// component.ts
@Component({
  selector: 'app-string-pipes',
  templateUrl: './string-pipes.component.html'
})
export class StringPipesComponent {
  title = 'angular pipe examples';
  message = 'Learn Angular Pipes';
  longText = 'This is a very long text that will be truncated using the slice pipe.';
  json = { name: 'John', age: 30, city: 'New York' };
}
```

```html
<!-- string-pipes.component.html -->
<h2>String Pipes</h2>

<!-- uppercase pipe -->
<p>{{ title | uppercase }}</p>
<!-- Output: ANGULAR PIPE EXAMPLES -->

<!-- lowercase pipe -->
<p>{{ message | lowercase }}</p>
<!-- Output: learn angular pipes -->

<!-- titlecase pipe -->
<p>{{ title | titlecase }}</p>
<!-- Output: Angular Pipe Examples -->

<!-- slice pipe -->
<p>{{ longText | slice:0:20 }}...</p>
<!-- Output: This is a very long t... -->

<!-- json pipe -->
<pre>{{ json | json }}</pre>
<!-- Output:
{
  "name": "John",
  "age": 30,
  "city": "New York"
}
-->
```

**Number and Math Pipes**

```typescript
// component.ts
@Component({
  selector: 'app-number-pipes',
  templateUrl: './number-pipes.component.html'
})
export class NumberPipesComponent {
  pi = 3.14159265359;
  e = 2.71828;
  amount = 1234.56;
  percentage = 0.8675;
  largeNumber = 1234567890;
}
```

```html
<!-- number-pipes.component.html -->
<h2>Number Pipes</h2>

<!-- number pipe with various formats -->
<p>Default: {{ pi | number }}</p>
<!-- Output: 3.142 -->

<p>With digits info: {{ pi | number:'1.2-5' }}</p>
<!-- Output: 3.14159 (at least 2 decimals, at most 5) -->

<p>Fixed number of digits: {{ e | number:'1.4-4' }}</p>
<!-- Output: 2.7183 -->

<!-- currency pipe -->
<p>Default currency: {{ amount | currency }}</p>
<!-- Output: $1,234.56 -->

<p>EUR: {{ amount | currency:'EUR' }}</p>
<!-- Output: €1,234.56 -->

<p>JPY with symbol: {{ amount | currency:'JPY':'symbol':'1.0-0' }}</p>
<!-- Output: ¥1,235 -->

<!-- percent pipe -->
<p>Default percent: {{ percentage | percent }}</p>
<!-- Output: 87% -->

<p>Percent with 2 decimals: {{ percentage | percent:'1.2-2' }}</p>
<!-- Output: 86.75% -->

<!-- Using decimal pipe for custom number formatting -->
<p>Decimal pipe: {{ largeNumber | number }}</p>
<!-- Output: 1,234,567,890 -->
```

**Date Pipe**

```typescript
// component.ts
@Component({
  selector: 'app-date-pipes',
  templateUrl: './date-pipes.component.html'
})
export class DatePipesComponent {
  currentDate = new Date();
  birthday = new Date(1990, 0, 15); // January 15, 1990
}
```

```html
<!-- date-pipes.component.html -->
<h2>Date Pipes</h2>

<!-- Date pipe with various formats -->
<p>Default date: {{ currentDate | date }}</p>
<!-- Output: May 1, 2025 -->

<p>Short date: {{ currentDate | date:'shortDate' }}</p>
<!-- Output: 5/1/25 -->

<p>Full date: {{ currentDate | date:'fullDate' }}</p>
<!-- Output: Thursday, May 1, 2025 -->

<p>Custom format: {{ currentDate | date:'MM/dd/yyyy' }}</p>
<!-- Output: 05/01/2025 -->

<p>With time: {{ currentDate | date:'medium' }}</p>
<!-- Output: May 1, 2025, 12:00:00 PM -->

<p>Short time: {{ currentDate | date:'shortTime' }}</p>
<!-- Output: 12:00 PM -->

<p>Day and month name: {{ birthday | date:'EEEE, MMMM d' }}</p>
<!-- Output: Monday, January 15 -->
```

**Other Built-in Pipes**

```typescript
// component.ts
@Component({
  selector: 'app-other-pipes',
  templateUrl: './other-pipes.component.html'
})
export class OtherPipesComponent {
  asyncData = new Promise<string>(resolve => {
    setTimeout(() => resolve('Async data loaded!'), 2000);
  });
  
  observable$ = interval(1000).pipe(
    take(5),
    map(v => `Observable value: ${v}`)
  );
  
  items = ['apple', 'banana', 'cherry', 'date'];
  selectedItem = null;
  
  nullValue = null;
  emptyString = '';
  zero = 0;
}
```

```html
<!-- other-pipes.component.html -->
<h2>Other Built-in Pipes</h2>

<!-- async pipe with Promise -->
<p>Async Promise: {{ asyncData | async }}</p>
<!-- Output after 2 seconds: Async data loaded! -->

<!-- async pipe with Observable -->
<p>Async Observable: {{ observable$ | async }}</p>
<!-- Output updates every second: Observable value: 0, 1, 2, etc. -->

<!-- i18nSelect pipe -->
<p>{{ selectedItem | i18nSelect: {
    'apple': 'You selected an apple',
    'banana': 'You selected a banana',
    'cherry': 'You selected a cherry',
    'date': 'You selected a date',
    'other': 'Please select an item'
  } }}
</p>

<!-- i18nPlural pipe -->
<p>{{ items.length | i18nPlural: {
    '=0': 'No items',
    '=1': 'One item',
    'other': '# items'
  } }}
</p>
<!-- Output: 4 items -->

<!-- KeyValue pipe -->
<div>
  <p>Object entries:</p>
  <ul>
    <li *ngFor="let entry of { name: 'John', age: 30 } | keyvalue">
      {{ entry.key }}: {{ entry.value }}
    </li>
  </ul>
</div>

<!-- nullish coalescing with the OR operator in expressions -->
<p>Null value: {{ nullValue || 'Default for null' }}</p>
<p>Empty string: {{ emptyString || 'Default for empty string' }}</p>
<p>Zero: {{ zero || 'Default for zero' }}</p>
```

### Pipe Chaining and Parameters

```html
<!-- Chaining multiple pipes -->
<p>{{ birthday | date:'fullDate' | uppercase }}</p>
<!-- Output: THURSDAY, MAY 1, 2025 -->

<!-- Pipe with parameters -->
<p>{{ pi | number:'1.5-5' }}</p>
<!-- Output: 3.14159 -->

<!-- Multiple parameters using colons -->
<p>{{ amount | currency:'GBP':'symbol':'1.2-2' }}</p>
<!-- Output: £1,234.56 -->
```

### Best Practices

* Use pipes for simple transformations in templates
* Chain pipes when needed, but avoid complex chains
* Consider pre-calculating values in the component for complex transformations
* Use the `async` pipe to handle observables and promises
* Be aware of pure vs. impure pipes and their performance implications
* Remember that pipes don't modify the original data
* For complex formatting requirements, consider creating a custom pipe

[Back to Top](#table-of-contents)

## Custom Pipes

Custom pipes allow you to create reusable transformations that are not covered by Angular's built-in pipes.

### Key Features

* Define transformations specific to your application
* Created using `@Pipe` decorator
* Must implement the `PipeTransform` interface
* Can be pure or impure (defaults to pure)
* Can accept multiple arguments

### Examples

**Basic Custom Pipe**

```typescript
// exponential-strength.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'exponentialStrength'
})
export class ExponentialStrengthPipe implements PipeTransform {
  transform(value: number, exponent: number = 1): number {
    return Math.pow(value, exponent);
  }
}

// app.module.ts
@NgModule({
  declarations: [
    AppComponent,
    ExponentialStrengthPipe
  ],
  // other configuration
})
export class AppModule { }
```

```html
<!-- component.html -->
<p>2 raised to the power of 5 is: {{ 2 | exponentialStrength:5 }}</p>
<!-- Output: 2 raised to the power of 5 is: 32 -->

<p>Base {{ base }} raised to the power of {{ exponent }} is: 
   {{ base | exponentialStrength:exponent }}</p>
```

```typescript
// component.ts
@Component({
  selector: 'app-custom-pipe-example',
  templateUrl: './custom-pipe-example.component.html'
})
export class CustomPipeExampleComponent {
  base = 2;
  exponent = 10;
}
```

**Filter Pipe Example**

```typescript
// filter.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'filter'
})
export class FilterPipe implements PipeTransform {
  transform(items: any[], searchText: string, field: string = ''): any[] {
    if (!items) return [];
    if (!searchText) return items;
    
    searchText = searchText.toLowerCase();
    
    return items.filter(item => {
      if (field) {
        // If a specific field is provided, search only in that field
        return item[field].toLowerCase().includes(searchText);
      } else {
        // Otherwise check if any property contains the search text
        return Object.keys(item).some(key => {
          return String(item[key]).toLowerCase().includes(searchText);
        });
      }
    });
  }
}
```

```html
<!-- component.html -->
<input type="text" [(ngModel)]="searchText" placeholder="Search...">

<ul>
  <li *ngFor="let user of users | filter:searchText:'name'">
    {{ user.name }} ({{ user.email }})
  </li>
</ul>
```

```typescript
// component.ts
@Component({
  selector: 'app-filter-pipe-example',
  templateUrl: './filter-pipe-example.component.html'
})
export class FilterPipeExampleComponent {
  searchText = '';
  users = [
    { id: 1, name: 'John Doe', email: 'john@example.com', role: 'Admin' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com', role: 'User' },
    { id: 3, name: 'Bob Johnson', email: 'bob@example.com', role: 'User' },
    { id: 4, name: 'Alice Brown', email: 'alice@example.com', role: 'Manager' }
  ];
}
```

**Impure Pipe Example**

```typescript
// countdown.pipe.ts
import { Pipe, PipeTransform, OnDestroy, ChangeDetectorRef } from '@angular/core';

@Pipe({
  name: 'countdown',
  pure: false // Impure pipe - will be triggered on each change detection cycle
})
export class CountdownPipe implements PipeTransform, OnDestroy {
  private timer: any;
  private lastValue: number = 0;
  private lastOutput: string = '';
  
  constructor(private changeDetectorRef: ChangeDetectorRef) {}
  
  transform(value: number): string {
    if (this.timer) {
      clearInterval(this.timer);
    }
    
    if (value !== this.lastValue) {
      this.lastValue = value;
      this.lastOutput = this.formatTime(value);
      
      if (value > 0) {
        let remainingTime = value;
        this.timer = setInterval(() => {
          remainingTime -= 1;
          if (remainingTime < 0) {
            clearInterval(this.timer);
          } else {
            this.lastOutput = this.formatTime(remainingTime);
            this.changeDetectorRef.markForCheck();
          }
        }, 1000);
      }
    }
    
    return this.lastOutput;
  }
  
  private formatTime(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  }
  
  ngOnDestroy() {
    if (this.timer) {
      clearInterval(this.timer);
    }
  }
}
```

```html
<!-- component.html -->
<p>Countdown: {{ countdownTime | countdown }}</p>
<button (click)="resetCountdown()">Reset Countdown</button>
```

```typescript
// component.ts
@Component({
  selector: 'app-impure-pipe-example',
  templateUrl: './impure-pipe-example.component.html'
})
export class ImpurePipeExampleComponent {
  countdownTime = 60; // 60 seconds
  
  resetCountdown() {
    this.countdownTime = 60;
  }
}
```

### Pure vs Impure Pipes

| Feature | Pure Pipe | Impure Pipe |
|---------|-----------|-------------|
| **Default** | Yes | No |
| **Change Detection** | Only when input values change | On every change detection cycle |
| **Performance** | Better | May impact performance |
| **Use Case** | Simple transformations of input data | Dynamic calculations, values that change over time |
| **Implementation** | `@Pipe({ name: 'pipeName' })` | `@Pipe({ name: 'pipeName', pure: false })` |
| **Examples** | Most transformations like formatting | Filtering, sorting, real-time updates |

### Best Practices

* Prefer pure pipes for better performance
* Implement `OnDestroy` in impure pipes to clean up resources
* Keep pipe logic simple and focused on a single transformation
* Avoid complex data manipulation in pipes, especially in impure pipes
* Document the API of your pipes, especially their parameters
* Remember that pure pipes operate only on primitive input changes or object references
* Test pipes thoroughly, especially edge cases like null inputs
* Consider pre-calculating values in the component for complex transformations

[Back to Top](#table-of-contents)

## Template Reference Variables

Template reference variables provide a way to directly access elements, components, or directives in your templates.

### Key Features

* Declared with a hash symbol (`#`) followed by a name
* Access DOM elements, Angular components, or directives
* Can be referenced anywhere in the template after declaration
* Useful for form validation, focusing elements, and passing references

### Examples

**Basic Template Reference Variables**

```html
<!-- component.html -->
<!-- Reference to a DOM element -->
<input #nameInput type="text" placeholder="Enter your name">
<button (click)="greet(nameInput.value)">Greet</button>

<!-- Reference to a button and toggle its disabled state -->
<button #submitButton [disabled]="isDisabled">Submit</button>
<button (click)="submitButton.disabled = !submitButton.disabled">
  Toggle Submit Button
</button>

<!-- Accessing the value property of an input element -->
<input #quantity type="number" value="1" min="1">
<button (click)="updateQuantity(quantity.value)">Update Quantity</button>
<p>Current quantity: {{ currentQuantity }}</p>
```

```typescript
// component.ts
@Component({
  selector: 'app-template-var-example',
  templateUrl: './template-var-example.component.html'
})
export class TemplateVarExampleComponent {
  isDisabled = false;
  currentQuantity = 1;
  
  greet(name: string) {
    if (name) {
      alert(`Hello, ${name}!`);
    } else {
      alert('Please enter a name first.');
    }
  }
  
  updateQuantity(quantity: string) {
    this.currentQuantity = parseInt(quantity);
  }
}
```

**Template Variables with NgForm and NgModel**

```html
<!-- component.html -->
<form #loginForm="ngForm" (ngSubmit)="onSubmit(loginForm)">
  <div>
    <label for="username">Username</label>
    <input 
      id="username" 
      name="username" 
      #username="ngModel" 
      [(ngModel)]="user.username" 
      required 
      minlength="4">
      
    <!-- Validation messages -->
    <div *ngIf="username.invalid && (username.dirty || username.touched)">
      <div *ngIf="username.errors?.['required']">Username is required</div>
      <div *ngIf="username.errors?.['minlength']">
        Username must be at least 4 characters long
      </div>
    </div>
  </div>
  
  <div>
    <label for="password">Password</label>
    <input 
      id="password" 
      name="password" 
      type="password" 
      #password="ngModel" 
      [(ngModel)]="user.password" 
      required>
      
    <!-- Validation messages -->
    <div *ngIf="password.invalid && (password.dirty || password.touched)">
      <div *ngIf="password.errors?.['required']">Password is required</div>
    </div>
  </div>
  
  <button type="submit" [disabled]="loginForm.invalid">Login</button>
  
  <!-- Form debugging information -->
  <div class="debug-info">
    <p>Form Valid: {{ loginForm.valid }}</p>
    <p>Form Values: {{ loginForm.value | json }}</p>
    <p>Username Errors: {{ username.errors | json }}</p>
  </div>
</form>
```

```typescript
// component.ts
@Component({
  selector: 'app-form-example',
  templateUrl: './form-example.component.html'
})
export class FormExampleComponent {
  user = {
    username: '',
    password: ''
  };
  
  onSubmit(form: NgForm) {
    if (form.valid) {
      console.log('Form submitted', form.value);
      // Process login
      form.resetForm();
    }
  }
}
```

**Accessing Directive References**

```typescript
// countdown.component.ts
@Component({
  selector: 'app-countdown',
  template: `
    <div>{{ remainingTime }} seconds remaining</div>
    <button (click)="start()">Start</button>
    <button (click)="pause()">Pause</button>
    <button (click)="reset()">Reset</button>
  `
})
export class CountdownComponent {
  @Input() startTime = 60;
  remainingTime = 0;
  private timerId: any;
  private isRunning = false;
  
  ngOnInit() {
    this.remainingTime = this.startTime;
  }
  
  start() {
    if (!this.isRunning) {
      this.isRunning = true;
      this.timerId = setInterval(() => {
        if (this.remainingTime > 0) {
          this.remainingTime--;
        } else {
          this.pause();
        }
      }, 1000);
    }
  }
  
  pause() {
    clearInterval(this.timerId);
    this.isRunning = false;
  }
  
  reset() {
    this.pause();
    this.remainingTime = this.startTime;
  }
}
```

```html
<!-- parent.component.html -->
<h2>Countdown Example</h2>
<app-countdown #countdown [startTime]="90"></app-countdown>

<div>
  <button (click)="countdown.start()">Start</button>
  <button (click)="countdown.pause()">Pause</button>
  <button (click)="countdown.reset()">Reset</button>
  <button (click)="setupFor30Seconds(countdown)">Setup for 30 Seconds</button>
</div>
```

```typescript
// parent.component.ts
@Component({
  selector: 'app-parent',
  templateUrl: './parent.component.html'
})
export class ParentComponent {
  setupFor30Seconds(countdown: CountdownComponent) {
    countdown.startTime = 30;
    countdown.reset();
  }
}
```

### Template Variables and ViewChild

```html
<!-- component.html -->
<input #nameInput type="text" placeholder="Enter your name">
<button (click)="focusNameInput()">Focus Input</button>
```

```typescript
// component.ts
import { Component, ViewChild, ElementRef, AfterViewInit } from '@angular/core';

@Component({
  selector: 'app-viewchild-example',
  templateUrl: './viewchild-example.component.html'
})
export class ViewChildExampleComponent implements AfterViewInit {
  @ViewChild('nameInput') nameInputRef!: ElementRef;
  
  ngAfterViewInit() {
    // Element is available after view initialization
    console.log('Input element:', this.nameInputRef.nativeElement);
  }
  
  focusNameInput() {
    this.nameInputRef.nativeElement.focus();
  }
}
```

### Best Practices

* Choose descriptive variable names for clarity
* Use template variables only within their declaration context
* Be careful with scope - variables declared in structural directives are only available within that instance
* Prefer ViewChild for accessing elements in component code (see ViewChild section)
* Remember that the variable refers to the element, directive, or component instance - not just its value
* Avoid excessive use of template variables for complex logic - keep templates clean and move logic to the component

[Back to Top](#table-of-contents)

<!-- ## Content Projection with ng-content -->
<!-- **Basic Content Projection**
**Multiple Content Projections with Select**
**Advanced Selectors for Content Projection** -->


## Content Projection with ng-content

Content projection is a powerful Angular feature that allows you to insert content from a parent component into a child component's template. This is Angular's implementation of the "transclusion" concept from AngularJS.

### Key Features:

- **Component Composition**: Create reusable components that can host dynamic content
- **Multiple Projection Slots**: Project content into specific locations within a component
- **Conditional Projection**: Show projected content based on specific conditions

### Basic Content Projection

The simplest form of content projection uses a single `<ng-content>` element to project all content from the parent component.

```typescript
// card.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-card',
  template: `
    <div class="card">
      <div class="card-content">
        <ng-content></ng-content>
      </div>
    </div>
  `,
  styles: [`
    .card {
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 16px;
      margin-bottom: 16px;
    }
  `]
})
export class CardComponent {
}
```

```typescript
// app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `
    <app-card>
      <h2>Card Title</h2>
      <p>This content will be projected into the card component.</p>
    </app-card>
  `
})
export class AppComponent {
}
```

**Sample Output:**
```
┌─────────────────────────────────────┐
│                                     │
│  Card Title                         │
│                                     │
│  This content will be projected     │
│  into the card component.           │
│                                     │
└─────────────────────────────────────┘
```

### Multi-Slot Content Projection

You can use the `select` attribute on `<ng-content>` to create multiple projection slots and target specific content to each slot.

```typescript
// panel.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-panel',
  template: `
    <div class="panel">
      <div class="panel-header">
        <ng-content select="[header]"></ng-content>
      </div>
      <div class="panel-body">
        <ng-content select="[body]"></ng-content>
      </div>
      <div class="panel-footer">
        <ng-content select="[footer]"></ng-content>
      </div>
    </div>
  `,
  styles: [`
    .panel {
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .panel-header {
      background-color: #f5f5f5;
      padding: 10px;
      border-bottom: 1px solid #ddd;
    }
    .panel-body {
      padding: 15px;
    }
    .panel-footer {
      background-color: #f5f5f5;
      padding: 10px;
      border-top: 1px solid #ddd;
    }
  `]
})
export class PanelComponent {
}
```

```typescript
// app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `
    <app-panel>
      <div header>
        <h3>Panel Title</h3>
      </div>
      <div body>
        <p>This is the main content of the panel.</p>
        <p>Content projection makes component composition easy.</p>
      </div>
      <div footer>
        <button>Save</button>
        <button>Cancel</button>
      </div>
    </app-panel>
  `
})
export class AppComponent {
}
```

**Sample Output:**
```
┌─────────────────────────────────────┐
│ Panel Title                         │
├─────────────────────────────────────┤
│                                     │
│ This is the main content of the     │
│ panel.                              │
│                                     │
│ Content projection makes component  │
│ composition easy.                   │
│                                     │
├─────────────────────────────────────┤
│ [Save]  [Cancel]                    │
└─────────────────────────────────────┘
```

### Selection Methods for ng-content

There are several ways to select content for projection:

```typescript
// advanced-card.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-advanced-card',
  template: `
    <div class="card">
      <!-- Select by CSS class -->
      <div class="title">
        <ng-content select=".card-title"></ng-content>
      </div>
      
      <!-- Select by element type -->
      <div class="image">
        <ng-content select="img"></ng-content>
      </div>
      
      <!-- Select by attribute -->
      <div class="content">
        <ng-content select="[card-content]"></ng-content>
      </div>
      
      <!-- Default content (without a select) -->
      <div class="footer">
        <ng-content></ng-content>
      </div>
    </div>
  `
})
export class AdvancedCardComponent {
}
```

```typescript
// app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `
    <app-advanced-card>
      <h2 class="card-title">My Advanced Card</h2>
      <img src="path/to/image.jpg" alt="Card Image">
      <p card-content>This content goes in the content section.</p>
      <div>This is unprojected content that goes to the default ng-content.</div>
    </app-advanced-card>
  `
})
export class AppComponent {
}
```

### Conditional Content Projection

You can conditionally display projected content using `*ngIf`:

```typescript
// conditional-card.component.ts
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-conditional-card',
  template: `
    <div class="card">
      <div class="card-header" *ngIf="showHeader">
        <ng-content select="[header]"></ng-content>
      </div>
      <div class="card-body">
        <ng-content></ng-content>
      </div>
    </div>
  `
})
export class ConditionalCardComponent {
  @Input() showHeader = true;
}
```

```typescript
// app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `
    <app-conditional-card [showHeader]="true">
      <h3 header>This header will be shown</h3>
      <p>This is the card body content.</p>
    </app-conditional-card>
    
    <app-conditional-card [showHeader]="false">
      <h3 header>This header will not be shown</h3>
      <p>Only the body content appears here.</p>
    </app-conditional-card>
  `
})
export class AppComponent {
}
```

### Best Practices:

- **Use Specific Selectors**: When using multi-slot projection, use specific and meaningful selectors
- **Default Content**: Provide default content using the `ng-content` tag with no selector for fallback content
- **Keep Components Focused**: Don't overuse content projection - keep components focused on a single responsibility
- **Document Projection Slots**: Clearly document the available projection slots for other developers

[Back to Top](#table-of-contents)

## ng-container and ng-template

`ng-container` and `ng-template` are powerful structural elements in Angular that help organize templates without introducing extra DOM elements or creating conditional UI fragments.

### Key Features:

- **No DOM Rendering**: Unlike regular HTML elements, these don't add extra nodes to the DOM
- **Structural Directive Group**: Group multiple elements under a single structural directive
- **Template References**: Create reusable template fragments
- **Contextual Template Rendering**: Render templates with specific contexts

### ng-container

`ng-container` is a logical container that doesn't create any DOM element. It's useful for grouping elements or applying structural directives without affecting the DOM structure.

```typescript
// list.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-list',
  template: `
    <div class="list-container">
      <h2>User List</h2>
      <ul>
        <!-- Without ng-container, we'd need a wrapper div -->
        <ng-container *ngFor="let user of users">
          <li *ngIf="user.active">
            {{ user.name }} ({{ user.role }})
          </li>
        </ng-container>
      </ul>
    </div>
  `
})
export class ListComponent {
  users = [
    { name: 'Alice', role: 'Admin', active: true },
    { name: 'Bob', role: 'User', active: false },
    { name: 'Charlie', role: 'User', active: true },
    { name: 'Diana', role: 'Manager', active: true }
  ];
}
```

**Sample Output:**
```
User List
• Alice (Admin)
• Charlie (User)
• Diana (Manager)
```

### Using Multiple Structural Directives

A common use case for `ng-container` is when you need to apply multiple structural directives, which is not possible on a single element:

```typescript
// product-list.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-product-list',
  template: `
    <div class="products">
      <ng-container *ngFor="let product of products">
        <ng-container *ngIf="product.inStock">
          <div class="product-card">
            <h3>{{ product.name }}</h3>
            <p>Price: ${{ product.price }}</p>
            <button>Add to Cart</button>
          </div>
        </ng-container>
      </ng-container>
    </div>
  `
})
export class ProductListComponent {
  products = [
    { name: 'Laptop', price: 1200, inStock: true },
    { name: 'Phone', price: 800, inStock: false },
    { name: 'Tablet', price: 500, inStock: true },
    { name: 'Headphones', price: 100, inStock: true }
  ];
}
```

### ng-template

`ng-template` defines a template that is not rendered by default but can be used for conditional rendering or with structural directives.

```typescript
// tabs.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-tabs',
  template: `
    <div class="tabs">
      <div class="tab-buttons">
        <button 
          *ngFor="let tab of tabs" 
          (click)="activeTab = tab.id"
          [class.active]="activeTab === tab.id"
        >
          {{ tab.title }}
        </button>
      </div>
      
      <div class="tab-content">
        <!-- Each template is defined but not rendered initially -->
        <ng-template #tab1>
          <h3>First Tab Content</h3>
          <p>This is the content for the first tab.</p>
        </ng-template>
        
        <ng-template #tab2>
          <h3>Second Tab Content</h3>
          <p>This is the content for the second tab.</p>
        </ng-template>
        
        <ng-template #tab3>
          <h3>Third Tab Content</h3>
          <p>This is the content for the third tab.</p>
        </ng-template>
        
        <!-- Conditionally render the active template -->
        <div [ngSwitch]="activeTab">
          <ng-container *ngSwitchCase="'tab1'" [ngTemplateOutlet]="tab1"></ng-container>
          <ng-container *ngSwitchCase="'tab2'" [ngTemplateOutlet]="tab2"></ng-container>
          <ng-container *ngSwitchCase="'tab3'" [ngTemplateOutlet]="tab3"></ng-container>
        </div>
      </div>
    </div>
  `,
  styles: [`
    .tab-buttons button {
      padding: 8px 16px;
      border: 1px solid #ccc;
      background: #f5f5f5;
      cursor: pointer;
    }
    .tab-buttons button.active {
      background: #fff;
      border-bottom: none;
    }
    .tab-content {
      padding: 16px;
      border: 1px solid #ccc;
      border-top: none;
    }
  `]
})
export class TabsComponent {
  tabs = [
    { id: 'tab1', title: 'Tab 1' },
    { id: 'tab2', title: 'Tab 2' },
    { id: 'tab3', title: 'Tab 3' }
  ];
  activeTab = 'tab1';
}
```

### ngTemplateOutlet

`ngTemplateOutlet` is a directive that renders an `ng-template` at a specified location. It can also pass context to the template:

```typescript
// template-outlet.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-template-outlet',
  template: `
    <div class="container">
      <h2>Template Outlet Example</h2>
      
      <!-- Define a reusable template -->
      <ng-template #userTemplate let-user="user" let-isAdmin="isAdmin">
        <div class="user-card" [class.admin]="isAdmin">
          <h3>{{ user.name }}</h3>
          <p>{{ user.email }}</p>
          <p>Role: {{ isAdmin ? 'Administrator' : 'Regular User' }}</p>
        </div>
      </ng-template>
      
      <!-- Use template with different contexts -->
      <div class="user-list">
        <h3>Regular Users</h3>
        <ng-container *ngFor="let user of regularUsers">
          <ng-container 
            [ngTemplateOutlet]="userTemplate" 
            [ngTemplateOutletContext]="{ user: user, isAdmin: false }"
          ></ng-container>
        </ng-container>
        
        <h3>Administrators</h3>
        <ng-container *ngFor="let user of adminUsers">
          <ng-container 
            [ngTemplateOutlet]="userTemplate" 
            [ngTemplateOutletContext]="{ user: user, isAdmin: true }"
          ></ng-container>
        </ng-container>
      </div>
    </div>
  `,
  styles: [`
    .user-card {
      border: 1px solid #ddd;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 4px;
    }
    .user-card.admin {
      border-color: #f44336;
      background-color: #ffebee;
    }
  `]
})
export class TemplateOutletComponent {
  regularUsers = [
    { name: 'John Smith', email: 'john@example.com' },
    { name: 'Sarah Johnson', email: 'sarah@example.com' }
  ];
  
  adminUsers = [
    { name: 'Mike Admin', email: 'mike@example.com' },
    { name: 'Emma Admin', email: 'emma@example.com' }
  ];
}
```

### Creating Custom Structural Directives

You can use `ng-template` to create custom structural directives:

```typescript
// unless.directive.ts
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appUnless]'
})
export class UnlessDirective {
  private hasView = false;

  constructor(
    private templateRef: TemplateRef<any>,
    private viewContainer: ViewContainerRef
  ) {}

  @Input() set appUnless(condition: boolean) {
    if (!condition && !this.hasView) {
      // If condition is false and view isn't created yet, create it
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.hasView = true;
    } else if (condition && this.hasView) {
      // If condition is true and view exists, destroy it
      this.viewContainer.clear();
      this.hasView = false;
    }
  }
}
```

```typescript
// component using custom directive
import { Component } from '@angular/core';

@Component({
  selector: 'app-unless-example',
  template: `
    <div>
      <button (click)="show = !show">Toggle Content</button>
      <p *appUnless="show">
        This content is shown when "show" is false (opposite of *ngIf)
      </p>
    </div>
  `
})
export class UnlessExampleComponent {
  show = false;
}
```

### Comparison: ng-container vs ng-template

| Feature | ng-container | ng-template |
|---------|-------------|-------------|
| DOM Rendering | Doesn't render a DOM element | Doesn't render unless explicitly used |
| Primary Use | Grouping elements without affecting DOM | Defining template fragments for later use |
| Rendering | Renders its children immediately | Renders only when referenced |
| Use with Structural Directives | Can host structural directives | Is used by structural directives |
| Context | Doesn't create a new context | Can define a context with input variables |

### Best Practices:

- **Use ng-container** to avoid extra DOM elements when grouping elements
- **Use ng-template** to define reusable template fragments
- **Keep Templates Small**: Break large templates into smaller, maintainable pieces
- **Meaningful Template References**: Use clear naming for template reference variables
- **Document Template Contexts**: When using complex context objects, document the expected structure

[Back to Top](#table-of-contents)

## ViewChild and ViewChildren

`ViewChild` and `ViewChildren` are decorators in Angular that provide access to DOM elements, directives, or components within the view of a component.

### Key Features:

- **Direct Element Access**: Query DOM elements in the component's view
- **Component Communication**: Access child component instances and their properties/methods
- **Directive Access**: Query instances of directives used in the view
- **Template References**: Access elements marked with template reference variables

### ViewChild

`ViewChild` is used to query a single element or directive from the view.

```typescript
// view-child.component.ts
import { Component, ViewChild, ElementRef, AfterViewInit } from '@angular/core';

@Component({
  selector: 'app-view-child',
  template: `
    <div class="container">
      <h2>ViewChild Example</h2>
      
      <!-- Reference to a DOM element -->
      <input #nameInput type="text" placeholder="Enter your name">
      
      <button (click)="focusInput()">Focus Input</button>
      
      <!-- Reference to a child component -->
      <app-counter #counter></app-counter>
      
      <button (click)="incrementCounter()">Increment Counter</button>
    </div>
  `
})
export class ViewChildComponent implements AfterViewInit {
  // Access the input element
  @ViewChild('nameInput') nameInputRef: ElementRef;
  
  // Access the counter component
  @ViewChild('counter') counterComponent: any; // Replace 'any' with actual component type
  
  // Alternative way to query by component type instead of template reference
  // @ViewChild(CounterComponent) counterComp: CounterComponent;
  
  ngAfterViewInit() {
    // ViewChild references are only available in ngAfterViewInit
    console.log('Input element:', this.nameInputRef.nativeElement);
    console.log('Counter component:', this.counterComponent);
  }
  
  focusInput() {
    // Directly interact with the DOM element
    this.nameInputRef.nativeElement.focus();
  }
  
  incrementCounter() {
    // Call a method on the child component
    this.counterComponent.increment();
  }
}
```

```typescript
// counter.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-counter',
  template: `
    <div class="counter">
      <h3>Counter: {{ count }}</h3>
    </div>
  `
})
export class CounterComponent {
  count = 0;
  
  increment() {
    this.count++;
  }
  
  decrement() {
    this.count--;
  }
  
  reset() {
    this.count = 0;
  }
}
```

### Static Query Option

The `@ViewChild` decorator has a static option that determines when the query is resolved:

```typescript
// Static query resolved before change detection
@ViewChild('someElement', { static: true }) someElement: ElementRef;

// Non-static query (default) resolved after first change detection
@ViewChild('dynamicElement') dynamicElement: ElementRef;
```

Static queries can be accessed in `ngOnInit`, while non-static queries are only guaranteed to be available in `ngAfterViewInit`.

### ViewChildren

`ViewChildren` queries multiple elements or directives that match the selector:

```typescript
// view-children.component.ts
import { Component, ViewChildren, QueryList, AfterViewInit } from '@angular/core';
import { TabComponent } from './tab.component';

@Component({
  selector: 'app-view-children',
  template: `
    <div class="tab-container">
      <h2>ViewChildren Example</h2>
      
      <!-- Multiple child components -->
      <app-tab title="Tab 1" [active]="activeTab === 0">
        Content for Tab 1
      </app-tab>
      
      <app-tab title="Tab 2" [active]="activeTab === 1">
        Content for Tab 2
      </app-tab>
      
      <app-tab title="Tab 3" [active]="activeTab === 2">
        Content for Tab 3
      </app-tab>
      
      <div class="tab-buttons">
        <button (click)="activateTab(i)" *ngFor="let tab of tabs; let i = index">
          {{ tab.title }}
        </button>
        <button (click)="logTabInfo()">Log Tab Info</button>
      </div>
    </div>
  `
})
export class ViewChildrenComponent implements AfterViewInit {
  @ViewChildren(TabComponent) tabComponents: QueryList<TabComponent>;
  
  tabs = [
    { title: 'Tab 1' },
    { title: 'Tab 2' },
    { title: 'Tab 3' }
  ];
  
  activeTab = 0;
  
  ngAfterViewInit() {
    // QueryList is accessible in ngAfterViewInit
    console.log('Tab components:', this.tabComponents);
    
    // Subscribe to changes in the QueryList
    this.tabComponents.changes.subscribe(tabList => {
      console.log('Tabs changed:', tabList);
    });
  }
  
  activateTab(index: number) {
    this.activeTab = index;
    
    // Access individual items in the QueryList
    this.tabComponents.forEach((tab, i) => {
      tab.active = i === index;
    });
  }
  
  logTabInfo() {
    // Convert QueryList to array and use array methods
    const tabsArray = this.tabComponents.toArray();
    
    console.log('Number of tabs:', this.tabComponents.length);
    console.log('First tab:', this.tabComponents.first);
    console.log('Last tab:', this.tabComponents.last);
    console.log('All tabs:', tabsArray);
  }
}
```

```typescript
// tab.component.ts
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-tab',
  template: `
    <div class="tab" [class.active]="active">
      <h3>{{ title }}</h3>
      <div class="content">
        <ng-content></ng-content>
      </div>
    </div>
  `,
  styles: [`
    .tab {
      display: none;
      border: 1px solid #ccc;
      padding: 10px;
      margin-bottom: 10px;
    }
    .tab.active {
      display: block;
    }
  `]
})
export class TabComponent {
  @Input() title: string;
  @Input() active = false;
}
```

### Reading Multiple Query Types

You can specify what to read from the query using the `read` option:

```typescript
// read-example.component.ts
import { Component, ViewChild, ViewChildren, ElementRef, QueryList, AfterViewInit } from '@angular/core';
import { NgModel } from '@angular/forms';

@Component({
  selector: 'app-read-example',
  template: `
    <div class="form-container">
      <h2>Read Option Example</h2>
      
      <!-- Same element, different query targets -->
      <input #nameInput [(ngModel)]="name" name="name">
      
      <div class="info">
        <p>Current value: {{ name }}</p>
        <button (click)="logInfo()">Log Information</button>
      </div>
    </div>
  `
})
export class ReadExampleComponent implements AfterViewInit {
  name = '';
  
  // Get the ElementRef of the input
  @ViewChild('nameInput') inputElement: ElementRef;
  
  // Get the NgModel directive from the same element
  @ViewChild('nameInput', { read: NgModel }) inputModel: NgModel;
  
  ngAfterViewInit() {
    console.log('Input element:', this.inputElement);
    console.log('NgModel directive:', this.inputModel);
  }
  
  logInfo() {
    // Access the DOM element
    console.log('Input value (from DOM):', this.inputElement.nativeElement.value);
    
    // Access the NgModel information
    console.log('Model value:', this.inputModel.value);
    console.log('Is model valid?', this.inputModel.valid);
    console.log('Is model dirty?', this.inputModel.dirty);
  }
}
```

### Dynamic Components with ViewChild

`ViewChild` can be used with dynamic components created using `ComponentFactoryResolver`:

```typescript
// dynamic-component.component.ts
import { 
  Component, 
  ViewChild, 
  ComponentFactoryResolver, 
  ViewContainerRef, 
  AfterViewInit 
} from '@angular/core';
import { AlertComponent } from './alert.component';

@Component({
  selector: 'app-dynamic-component',
  template: `
    <div class="container">
      <h2>Dynamic Component with ViewChild</h2>
      
      <button (click)="showAlert('info', 'This is an information message')">
        Show Info Alert
      </button>
      <button (click)="showAlert('warning', 'Warning! This is important')">
        Show Warning Alert
      </button>
      <button (click)="showAlert('error', 'Error occurred! Please try again')">
        Show Error Alert
      </button>
      
      <!-- This container will host our dynamic components -->
      <div class="alerts-container">
        <ng-container #alertContainer></ng-container>
      </div>
    </div>
  `
})
export class DynamicComponentComponent implements AfterViewInit {
  @ViewChild('alertContainer', { read: ViewContainerRef }) alertContainer: ViewContainerRef;
  
  constructor(private componentFactoryResolver: ComponentFactoryResolver) {}
  
  ngAfterViewInit() {
    console.log('Alert container:', this.alertContainer);
  }
  
  showAlert(type: 'info' | 'warning' | 'error', message: string) {
    // Clear previous alerts
    this.alertContainer.clear();
    
    // Create component factory
    const factory = this.componentFactoryResolver.resolveComponentFactory(AlertComponent);
    
    // Create component instance
    const componentRef = this.alertContainer.createComponent(factory);
    
    // Set component inputs
    componentRef.instance.type = type;
    componentRef.instance.message = message;
    
    // Auto-remove after 3 seconds
    setTimeout(() => {
      componentRef.destroy();
    }, 3000);
  }
}
```

```typescript
// alert.component.ts
import { Component, Input, OnInit } from '@angular/core';

@Component({
  selector: 'app-alert',
  template: `
    <div class="alert" [ngClass]="'alert-' + type">
      <span class="close" (click)="onClose()">&times;</span>
      <strong>{{ typeTitle }}:</strong> {{ message }}
    </div>
  `,
  styles: [`
    .alert {
      padding: 15px;
      margin-bottom: 15px;
      border-radius: 4px;
    }
    .alert-info {
      background-color: #d9edf7;
      border: 1px solid #bce8f1;
      color: #31708f;
    }
    .alert-warning {
      background-color: #fcf8e3;
      border: 1px solid #faebcc;
      color: #8a6d3b;
    }
    .alert-error {
      background-color: #f2dede;
      border: 1px solid #ebccd1;
      color: #a94442;
    }
    .close {
      cursor: pointer;
      float: right;
      font-weight: bold;
    }
  `]
})
export class AlertComponent implements OnInit {
  @Input() type: 'info' | 'warning' | 'error' = 'info';
  @Input() message: string;
  
  typeTitle: string;
  
  ngOnInit() {
    // Set title based on type
    this.typeTitle = {
      'info': 'Information',
      'warning': 'Warning',
      'error': 'Error'
    }[this.type];
  }
  
  onClose() {
    // In a real app, we would emit an event to the parent
    console.log('Alert closed');
  }
}
```

### Best Practices:

- **Use Appropriate Lifecycle Hooks**: 
  - For static queries (static: true), use `ngOnInit`
  - For non-static queries, use `ngAfterViewInit`
- **Avoid DOM Manipulation**: When possible, use data binding rather than direct DOM manipulation
- **Proper Error Handling**: Always check if the view child exists before accessing it
- **Specify Return Type**: Always specify the correct type for @ViewChild and @ViewChildren to get proper type checking
- **Prefer Component Interaction**: Use @Input/@Output for parent-child communication when possible, and @ViewChild only when necessary
- **Use read Option Carefully**: Only use the read option when you need a specific token from an element
- **Handle QueryList Changes**: Subscribe to changes on QueryList when dealing with dynamic content

[Back to Top](#table-of-contents)